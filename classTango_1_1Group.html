<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.19"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tango Core Classes Reference: Tango::Group Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Tango Core Classes Reference
   &#160;<span id="projectnumber">9.3.4</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classTango_1_1Group.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classTango_1_1Group-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Tango::Group Class Reference<div class="ingroups"><a class="el" href="group__Client.html">Client classes</a> &raquo; <a class="el" href="group__Grp.html">Group Client classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>High level class allowing the user to handle <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> group.  
 <a href="classTango_1_1Group.html#details">More...</a></p>

<p><code>#include &quot;tango.h&quot;</code></p>

<p>Inherits Tango::GroupElement.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructor and destructor</div></td></tr>
<tr class="memitem:aa1bcfe79af9522faa65449efb128fc3e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#aa1bcfe79af9522faa65449efb128fc3e">Group</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:aa1bcfe79af9522faa65449efb128fc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classTango_1_1Group.html" title="High level class allowing the user to handle Tango group.">Group</a> instance.  <a href="classTango_1_1Group.html#aa1bcfe79af9522faa65449efb128fc3e">More...</a><br /></td></tr>
<tr class="separator:aa1bcfe79af9522faa65449efb128fc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7a0b40d37852923131e9bce68dd9ff"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#acd7a0b40d37852923131e9bce68dd9ff">~Group</a> ()</td></tr>
<tr class="memdesc:acd7a0b40d37852923131e9bce68dd9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classTango_1_1Group.html" title="High level class allowing the user to handle Tango group.">Group</a> instance.  <a href="classTango_1_1Group.html#acd7a0b40d37852923131e9bce68dd9ff">More...</a><br /></td></tr>
<tr class="separator:acd7a0b40d37852923131e9bce68dd9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Group management related methods</h2></td></tr>
<tr class="memitem:a2cbaa3bf6cecdb6fb33a387c79556e58"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a2cbaa3bf6cecdb6fb33a387c79556e58">add</a> (<a class="el" href="classTango_1_1Group.html">Group</a> *group, int tmo_ms=-1)</td></tr>
<tr class="memdesc:a2cbaa3bf6cecdb6fb33a387c79556e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches a (sub) group.  <a href="classTango_1_1Group.html#a2cbaa3bf6cecdb6fb33a387c79556e58">More...</a><br /></td></tr>
<tr class="separator:a2cbaa3bf6cecdb6fb33a387c79556e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cae4533d2ab5f218d6b65748f8374f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#ad0cae4533d2ab5f218d6b65748f8374f">add</a> (const std::string &amp;pattern, int tmo_ms=-1)</td></tr>
<tr class="memdesc:ad0cae4533d2ab5f218d6b65748f8374f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches any device which name matches the specified pattern.  <a href="classTango_1_1Group.html#ad0cae4533d2ab5f218d6b65748f8374f">More...</a><br /></td></tr>
<tr class="separator:ad0cae4533d2ab5f218d6b65748f8374f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633d0ced915368b8b084adb3a215cca5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a633d0ced915368b8b084adb3a215cca5">add</a> (const std::vector&lt; std::string &gt; &amp;patterns, int tmo_ms=-1)</td></tr>
<tr class="memdesc:a633d0ced915368b8b084adb3a215cca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches any device which name matches one of the specified pattern.  <a href="classTango_1_1Group.html#a633d0ced915368b8b084adb3a215cca5">More...</a><br /></td></tr>
<tr class="separator:a633d0ced915368b8b084adb3a215cca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7763925b6e27ccf237b13fa7f98009"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#acd7763925b6e27ccf237b13fa7f98009">remove</a> (const std::string &amp;pattern, bool fwd=true)</td></tr>
<tr class="memdesc:acd7763925b6e27ccf237b13fa7f98009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any group or device which name matches the specified pattern.  <a href="classTango_1_1Group.html#acd7763925b6e27ccf237b13fa7f98009">More...</a><br /></td></tr>
<tr class="separator:acd7763925b6e27ccf237b13fa7f98009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2561673c34638016106a6fba3c0b95ee"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a2561673c34638016106a6fba3c0b95ee">remove</a> (const std::vector&lt; std::string &gt; &amp;patterns, bool fwd=true)</td></tr>
<tr class="memdesc:a2561673c34638016106a6fba3c0b95ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes any group or device which name matches any of the specified patterns.  <a href="classTango_1_1Group.html#a2561673c34638016106a6fba3c0b95ee">More...</a><br /></td></tr>
<tr class="separator:a2561673c34638016106a6fba3c0b95ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12404b76c3e64df47467a1260591e7df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a12404b76c3e64df47467a1260591e7df">remove_all</a> ()</td></tr>
<tr class="memdesc:a12404b76c3e64df47467a1260591e7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements in the group.  <a href="classTango_1_1Group.html#a12404b76c3e64df47467a1260591e7df">More...</a><br /></td></tr>
<tr class="separator:a12404b76c3e64df47467a1260591e7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2885b00242d3a2d199836e48186dd71e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a2885b00242d3a2d199836e48186dd71e">contains</a> (const std::string &amp;pattern, bool fwd=true)</td></tr>
<tr class="memdesc:a2885b00242d3a2d199836e48186dd71e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the hierarchy contains groups and/or devices which name matches the specified pattern.  <a href="classTango_1_1Group.html#a2885b00242d3a2d199836e48186dd71e">More...</a><br /></td></tr>
<tr class="separator:a2885b00242d3a2d199836e48186dd71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7d5db7e814e378bf30f940865885b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDeviceProxy.html">DeviceProxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#adc7d5db7e814e378bf30f940865885b8">get_device</a> (const std::string &amp;device_name)</td></tr>
<tr class="memdesc:adc7d5db7e814e378bf30f940865885b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the specified device.  <a href="classTango_1_1Group.html#adc7d5db7e814e378bf30f940865885b8">More...</a><br /></td></tr>
<tr class="separator:adc7d5db7e814e378bf30f940865885b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29685f1ad173310c2cf695390cedd362"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDeviceProxy.html">DeviceProxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a29685f1ad173310c2cf695390cedd362">get_device</a> (long idx)</td></tr>
<tr class="memdesc:a29685f1ad173310c2cf695390cedd362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the "idx-th" device in the hierarchy.  <a href="classTango_1_1Group.html#a29685f1ad173310c2cf695390cedd362">More...</a><br /></td></tr>
<tr class="separator:a29685f1ad173310c2cf695390cedd362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3b781cd10d28770cb584c55c065534"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classDeviceProxy.html">DeviceProxy</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#aea3b781cd10d28770cb584c55c065534">operator[]</a> (long idx)</td></tr>
<tr class="memdesc:aea3b781cd10d28770cb584c55c065534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the "idx-th" device in the hierarchy.  <a href="classTango_1_1Group.html#aea3b781cd10d28770cb584c55c065534">More...</a><br /></td></tr>
<tr class="separator:aea3b781cd10d28770cb584c55c065534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ddf85f5805e6e99656cbe554ecf96e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTango_1_1Group.html">Group</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a75ddf85f5805e6e99656cbe554ecf96e">get_group</a> (const std::string &amp;group_name)</td></tr>
<tr class="memdesc:a75ddf85f5805e6e99656cbe554ecf96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the specified group.  <a href="classTango_1_1Group.html#a75ddf85f5805e6e99656cbe554ecf96e">More...</a><br /></td></tr>
<tr class="separator:a75ddf85f5805e6e99656cbe554ecf96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afb6e934e20fb757538b873fef265e5"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a1afb6e934e20fb757538b873fef265e5">get_size</a> (bool fwd=true)</td></tr>
<tr class="memdesc:a1afb6e934e20fb757538b873fef265e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of devices in the hierarchy.  <a href="classTango_1_1Group.html#a1afb6e934e20fb757538b873fef265e5">More...</a><br /></td></tr>
<tr class="separator:a1afb6e934e20fb757538b873fef265e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35a3426e304c3d87607997261aff1d22"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a35a3426e304c3d87607997261aff1d22">get_device_list</a> (bool fwd=true)</td></tr>
<tr class="memdesc:a35a3426e304c3d87607997261aff1d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the list of devices currently in the hierarchy.  <a href="classTango_1_1Group.html#a35a3426e304c3d87607997261aff1d22">More...</a><br /></td></tr>
<tr class="separator:a35a3426e304c3d87607997261aff1d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
a la Deviceproxy interface</h2></td></tr>
<tr class="memitem:aa7cd5c6f1be1a85c244c7a4ec99081ec"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#aa7cd5c6f1be1a85c244c7a4ec99081ec">ping</a> (bool fwd=true)</td></tr>
<tr class="memdesc:aa7cd5c6f1be1a85c244c7a4ec99081ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ping all devices in a group.  <a href="classTango_1_1Group.html#aa7cd5c6f1be1a85c244c7a4ec99081ec">More...</a><br /></td></tr>
<tr class="separator:aa7cd5c6f1be1a85c244c7a4ec99081ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92242b89511557c3296480ee19b790b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a92242b89511557c3296480ee19b790b2">set_timeout_millis</a> (int tmo_ms)</td></tr>
<tr class="memdesc:a92242b89511557c3296480ee19b790b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set client side timeout for all devices in the group.  <a href="classTango_1_1Group.html#a92242b89511557c3296480ee19b790b2">More...</a><br /></td></tr>
<tr class="separator:a92242b89511557c3296480ee19b790b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8511861bcd0723b9e726e2bfaac6de3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a8511861bcd0723b9e726e2bfaac6de3a">command_inout</a> (const std::string &amp;c, bool fwd=true)</td></tr>
<tr class="memdesc:a8511861bcd0723b9e726e2bfaac6de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on a group.  <a href="classTango_1_1Group.html#a8511861bcd0723b9e726e2bfaac6de3a">More...</a><br /></td></tr>
<tr class="separator:a8511861bcd0723b9e726e2bfaac6de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02f116ab2fcaed5850b0301dd8095a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#ab02f116ab2fcaed5850b0301dd8095a7">command_inout</a> (const std::string &amp;c, const <a class="el" href="classDeviceData.html">DeviceData</a> &amp;d, bool fwd=true)</td></tr>
<tr class="memdesc:ab02f116ab2fcaed5850b0301dd8095a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with the same input data on a group.  <a href="classTango_1_1Group.html#ab02f116ab2fcaed5850b0301dd8095a7">More...</a><br /></td></tr>
<tr class="separator:ab02f116ab2fcaed5850b0301dd8095a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50c9d4d35e13d374dfc22afb6f6ab01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#ae50c9d4d35e13d374dfc22afb6f6ab01">command_inout</a> (const std::string &amp;c, const std::vector&lt; <a class="el" href="classDeviceData.html">DeviceData</a> &gt; &amp;d, bool fwd=true)</td></tr>
<tr class="memdesc:ae50c9d4d35e13d374dfc22afb6f6ab01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with the different input data on a group (Using <a class="el" href="classDeviceData.html" title="Fundamental type for sending and receiving data from device commands.">DeviceData</a> class instances)  <a href="classTango_1_1Group.html#ae50c9d4d35e13d374dfc22afb6f6ab01">More...</a><br /></td></tr>
<tr class="separator:ae50c9d4d35e13d374dfc22afb6f6ab01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54f51f9f9bbac8ad686199245274bbf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad54f51f9f9bbac8ad686199245274bbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#ad54f51f9f9bbac8ad686199245274bbf">command_inout</a> (const std::string &amp;c, const std::vector&lt; T &gt; &amp;d, bool fwd=true)</td></tr>
<tr class="memdesc:ad54f51f9f9bbac8ad686199245274bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with the different input data on a group.  <a href="classTango_1_1Group.html#ad54f51f9f9bbac8ad686199245274bbf">More...</a><br /></td></tr>
<tr class="separator:ad54f51f9f9bbac8ad686199245274bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d95994ae0c6e3836e33f8acef6a038"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a53d95994ae0c6e3836e33f8acef6a038">command_inout_asynch</a> (const std::string &amp;c, bool fgt=false, bool fwd=true)</td></tr>
<tr class="memdesc:a53d95994ae0c6e3836e33f8acef6a038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on each device in the group asynchronously.  <a href="classTango_1_1Group.html#a53d95994ae0c6e3836e33f8acef6a038">More...</a><br /></td></tr>
<tr class="separator:a53d95994ae0c6e3836e33f8acef6a038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd15b110efd88ffa47233ba4244a273"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a2bd15b110efd88ffa47233ba4244a273">command_inout_asynch</a> (const std::string &amp;c, const <a class="el" href="classDeviceData.html">DeviceData</a> &amp;d, bool fgt=false, bool fwd=true)</td></tr>
<tr class="memdesc:a2bd15b110efd88ffa47233ba4244a273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with same input data on each device in the group asynchronously.  <a href="classTango_1_1Group.html#a2bd15b110efd88ffa47233ba4244a273">More...</a><br /></td></tr>
<tr class="separator:a2bd15b110efd88ffa47233ba4244a273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592a4fbe47296a6b27a142a38bbde6e8"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a592a4fbe47296a6b27a142a38bbde6e8">command_inout_asynch</a> (const std::string &amp;c, const std::vector&lt; <a class="el" href="classDeviceData.html">DeviceData</a> &gt; &amp;d, bool fgt=false, bool fwd=true)</td></tr>
<tr class="memdesc:a592a4fbe47296a6b27a142a38bbde6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with different input data (using <a class="el" href="classDeviceData.html" title="Fundamental type for sending and receiving data from device commands.">DeviceData</a> object) on each device in the group asynchronously.  <a href="classTango_1_1Group.html#a592a4fbe47296a6b27a142a38bbde6e8">More...</a><br /></td></tr>
<tr class="separator:a592a4fbe47296a6b27a142a38bbde6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b53cb8fb55e3b96d056cb9971aaab4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17b53cb8fb55e3b96d056cb9971aaab4"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a17b53cb8fb55e3b96d056cb9971aaab4">command_inout_asynch</a> (const std::string &amp;c, const std::vector&lt; T &gt; &amp;d, bool fgt=false, bool fwd=true)</td></tr>
<tr class="memdesc:a17b53cb8fb55e3b96d056cb9971aaab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with different input data on each device in the group asynchronously.  <a href="classTango_1_1Group.html#a17b53cb8fb55e3b96d056cb9971aaab4">More...</a><br /></td></tr>
<tr class="separator:a17b53cb8fb55e3b96d056cb9971aaab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed06d2a84d479a13c2e98781af748e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#abed06d2a84d479a13c2e98781af748e8">command_inout_reply</a> (long req_id, long tmo_ms=0)</td></tr>
<tr class="memdesc:abed06d2a84d479a13c2e98781af748e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the results of an asynchronous command.  <a href="classTango_1_1Group.html#abed06d2a84d479a13c2e98781af748e8">More...</a><br /></td></tr>
<tr class="separator:abed06d2a84d479a13c2e98781af748e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c584b30ee4e69eed2de59cb548c4134"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupAttrReplyList.html">GroupAttrReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a3c584b30ee4e69eed2de59cb548c4134">read_attribute</a> (const std::string &amp;a, bool fwd=true)</td></tr>
<tr class="memdesc:a3c584b30ee4e69eed2de59cb548c4134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an attribute on each device in the group.  <a href="classTango_1_1Group.html#a3c584b30ee4e69eed2de59cb548c4134">More...</a><br /></td></tr>
<tr class="separator:a3c584b30ee4e69eed2de59cb548c4134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4088df9970f1f1c7d6ae8c29563369f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupAttrReplyList.html">GroupAttrReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#ab4088df9970f1f1c7d6ae8c29563369f">read_attributes</a> (const std::vector&lt; std::string &gt; &amp;al, bool fwd=true)</td></tr>
<tr class="memdesc:ab4088df9970f1f1c7d6ae8c29563369f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads several attributes on each device in the group.  <a href="classTango_1_1Group.html#ab4088df9970f1f1c7d6ae8c29563369f">More...</a><br /></td></tr>
<tr class="separator:ab4088df9970f1f1c7d6ae8c29563369f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fa50b55ebad69d6fd819f658703997"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a08fa50b55ebad69d6fd819f658703997">read_attribute_asynch</a> (const std::string &amp;a, bool fwd=true)</td></tr>
<tr class="memdesc:a08fa50b55ebad69d6fd819f658703997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an attribute on each device in the group asynchronously.  <a href="classTango_1_1Group.html#a08fa50b55ebad69d6fd819f658703997">More...</a><br /></td></tr>
<tr class="separator:a08fa50b55ebad69d6fd819f658703997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9431b4c0673e3824c31b00028e894d31"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a9431b4c0673e3824c31b00028e894d31">read_attributes_asynch</a> (const std::vector&lt; std::string &gt; &amp;al, bool fwd=true)</td></tr>
<tr class="memdesc:a9431b4c0673e3824c31b00028e894d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads several attributes on each device in the group asynchronously.  <a href="classTango_1_1Group.html#a9431b4c0673e3824c31b00028e894d31">More...</a><br /></td></tr>
<tr class="separator:a9431b4c0673e3824c31b00028e894d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c580ba756e84843f29e126efb8c1986"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupAttrReplyList.html">GroupAttrReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a9c580ba756e84843f29e126efb8c1986">read_attribute_reply</a> (long req_id, long tmo_ms=0)</td></tr>
<tr class="memdesc:a9c580ba756e84843f29e126efb8c1986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the results of an asynchronous attribute reading.  <a href="classTango_1_1Group.html#a9c580ba756e84843f29e126efb8c1986">More...</a><br /></td></tr>
<tr class="separator:a9c580ba756e84843f29e126efb8c1986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a83261058e5c52803e502c01380b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupAttrReplyList.html">GroupAttrReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#ab1a83261058e5c52803e502c01380b79">read_attributes_reply</a> (long req_id, long tmo_ms=0)</td></tr>
<tr class="memdesc:ab1a83261058e5c52803e502c01380b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the results of an asynchronous attributes reading.  <a href="classTango_1_1Group.html#ab1a83261058e5c52803e502c01380b79">More...</a><br /></td></tr>
<tr class="separator:ab1a83261058e5c52803e502c01380b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64da6f972d7dca15b192c66226e3d4c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupReplyList.html">GroupReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a64da6f972d7dca15b192c66226e3d4c7">write_attribute</a> (const <a class="el" href="classDeviceAttribute.html">DeviceAttribute</a> &amp;d, bool fwd=true)</td></tr>
<tr class="memdesc:a64da6f972d7dca15b192c66226e3d4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an attribute on each device in the group.  <a href="classTango_1_1Group.html#a64da6f972d7dca15b192c66226e3d4c7">More...</a><br /></td></tr>
<tr class="separator:a64da6f972d7dca15b192c66226e3d4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05e427721de6903871b6c2dc505dec7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupReplyList.html">GroupReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#ac05e427721de6903871b6c2dc505dec7">write_attribute</a> (const std::vector&lt; <a class="el" href="classDeviceAttribute.html">DeviceAttribute</a> &gt; &amp;d, bool fwd=true)</td></tr>
<tr class="memdesc:ac05e427721de6903871b6c2dc505dec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes several attributes on each device in the group (using <a class="el" href="classDeviceAttribute.html" title="Fundamental type for sending an dreceiving data to and from device attributes.">DeviceAttribute</a>)  <a href="classTango_1_1Group.html#ac05e427721de6903871b6c2dc505dec7">More...</a><br /></td></tr>
<tr class="separator:ac05e427721de6903871b6c2dc505dec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b513a1564a1a4f9e5482dfcef528d0c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b513a1564a1a4f9e5482dfcef528d0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupReplyList.html">GroupReplyList</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a5b513a1564a1a4f9e5482dfcef528d0c">write_attribute</a> (const std::string &amp;n, const std::vector&lt; T &gt; &amp;d, bool fwd=true)</td></tr>
<tr class="memdesc:a5b513a1564a1a4f9e5482dfcef528d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes one attributes on each device in the group with specific value per device.  <a href="classTango_1_1Group.html#a5b513a1564a1a4f9e5482dfcef528d0c">More...</a><br /></td></tr>
<tr class="separator:a5b513a1564a1a4f9e5482dfcef528d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ead1c134a086855da1e809aa8f13d03"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a2ead1c134a086855da1e809aa8f13d03">write_attribute_asynch</a> (const <a class="el" href="classDeviceAttribute.html">DeviceAttribute</a> &amp;d, bool fwd=true)</td></tr>
<tr class="memdesc:a2ead1c134a086855da1e809aa8f13d03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an attribute on each device in the group asynchronously.  <a href="classTango_1_1Group.html#a2ead1c134a086855da1e809aa8f13d03">More...</a><br /></td></tr>
<tr class="separator:a2ead1c134a086855da1e809aa8f13d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edbe29d80b0c686840c01bac7304197"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a2edbe29d80b0c686840c01bac7304197">write_attribute_asynch</a> (const std::vector&lt; <a class="el" href="classDeviceAttribute.html">DeviceAttribute</a> &gt; &amp;d, bool fwd=true)</td></tr>
<tr class="memdesc:a2edbe29d80b0c686840c01bac7304197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes several attributes on each device in the group asynchronously.  <a href="classTango_1_1Group.html#a2edbe29d80b0c686840c01bac7304197">More...</a><br /></td></tr>
<tr class="separator:a2edbe29d80b0c686840c01bac7304197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187f0b29e02bf82b74f21b55c4252d62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a187f0b29e02bf82b74f21b55c4252d62"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#a187f0b29e02bf82b74f21b55c4252d62">write_attribute_asynch</a> (const std::string &amp;a, const std::vector&lt; T &gt; &amp;d, bool fwd=true)</td></tr>
<tr class="memdesc:a187f0b29e02bf82b74f21b55c4252d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an attribute on each device in the group asynchronously (Without <a class="el" href="classDeviceAttribute.html" title="Fundamental type for sending an dreceiving data to and from device attributes.">DeviceAttribute</a> data)  <a href="classTango_1_1Group.html#a187f0b29e02bf82b74f21b55c4252d62">More...</a><br /></td></tr>
<tr class="separator:a187f0b29e02bf82b74f21b55c4252d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa300f78715baea10d390b7e7489e0506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTango_1_1GroupReplyList.html">GroupReplyList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTango_1_1Group.html#aa300f78715baea10d390b7e7489e0506">write_attribute_reply</a> (long req_id, long tmo_ms=0)</td></tr>
<tr class="memdesc:aa300f78715baea10d390b7e7489e0506"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the acknowledgements of an asynchronous attribute writing.  <a href="classTango_1_1Group.html#aa300f78715baea10d390b7e7489e0506">More...</a><br /></td></tr>
<tr class="separator:aa300f78715baea10d390b7e7489e0506"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>High level class allowing the user to handle <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> group. </p>
<p>$Author$ $Revision$ </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa1bcfe79af9522faa65449efb128fc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bcfe79af9522faa65449efb128fc3e">&#9670;&nbsp;</a></span>Group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Tango::Group::Group </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classTango_1_1Group.html" title="High level class allowing the user to handle Tango group.">Group</a> instance. </p>
<p>Instanciate an empty group. The group name allows retrieving a sub-group in the hierarchy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The group name </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd7a0b40d37852923131e9bce68dd9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7a0b40d37852923131e9bce68dd9ff">&#9670;&nbsp;</a></span>~Group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Tango::Group::~Group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classTango_1_1Group.html" title="High level class allowing the user to handle Tango group.">Group</a> instance. </p>
<p>Delete a group and all its elements. Be aware that a group always gets the ownership of its children and deletes themwhen it is itself deleted. Therefore, never try to delete a <a class="el" href="classTango_1_1Group.html" title="High level class allowing the user to handle Tango group.">Group</a> (respectively a <a class="el" href="classDeviceProxy.html" title="High level class which provides the client with an easy-to-use interface to TANGO devices.">DeviceProxy</a>) returned by a call to <em><a class="el" href="classTango_1_1Group.html#a75ddf85f5805e6e99656cbe554ecf96e" title="Returns a reference to the specified group.">Tango::Group::get_group()</a></em> (respectively to <em><a class="el" href="classTango_1_1Group.html#adc7d5db7e814e378bf30f940865885b8" title="Returns a reference to the specified device.">Tango::Group::get_device()</a></em>). Use the <em><a class="el" href="classTango_1_1Group.html#acd7763925b6e27ccf237b13fa7f98009" title="Removes any group or device which name matches the specified pattern.">Tango::Group::remove()</a></em> method instead. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad0cae4533d2ab5f218d6b65748f8374f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cae4533d2ab5f218d6b65748f8374f">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Tango::Group::add </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmo_ms</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches any device which name matches the specified pattern. </p>
<p>The pattern parameter can be a simple device name or a device name pattern (e.g. domain_* / family/ member_*). This method first asks to the <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> database the list of device names matching the pattern. Devices are then attached to the group in the order in which they are returned by the database. Any device already present in the hierarchy (i.e. a device belonging to the group or to one of its subgroups) is silently ignored but its client side timeout is set to timeout_ms milliseconds if timeout_ms is different from -1. Set the client side timeout of each device matching the specified pattern to timeout_ms milliseconds if timeout_ms is different from -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The device selection pattern </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmo_ms</td><td>The timeout value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a633d0ced915368b8b084adb3a215cca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633d0ced915368b8b084adb3a215cca5">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Tango::Group::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmo_ms</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches any device which name matches one of the specified pattern. </p>
<p>The patterns parameter can be an array of device names and/or device name patterns. Thismethod first asks to the <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> database the list of device namesmatching one the patterns. Devices are then attached to the group in the order in which they are returned by the database. Any device already present in the hierarchy (i.e. a device belonging to the group or to one of its subgroups), is silently ignored but its client side timeout is set to timeout_ms milliseconds if timeout_ms is different from -1. If timeout_ms is different from -1, the client side timeouts of all devices matching the specified patterns are set to timeout_ms milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patterns</td><td>The device selection pattern list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmo_ms</td><td>The timeout value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cbaa3bf6cecdb6fb33a387c79556e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbaa3bf6cecdb6fb33a387c79556e58">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Tango::Group::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTango_1_1Group.html">Group</a> *&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmo_ms</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches a (sub) group. </p>
<p>Be aware that a group always gets the ownership of its children and deletes them when it is itself deleted. Therefore, never try to delete a <a class="el" href="classTango_1_1Group.html" title="High level class allowing the user to handle Tango group.">Group</a> attached to a <a class="el" href="classTango_1_1Group.html" title="High level class allowing the user to handle Tango group.">Group</a>. Use the <a class="el" href="classTango_1_1Group.html#acd7763925b6e27ccf237b13fa7f98009" title="Removes any group or device which name matches the specified pattern.">Group::remove()</a> method instead. If timeout_ms parameter is different from -1, the client side timeout associated to each device composing the group added is set to timeout_ms milliseconds. If timeout_ms is -1, timeouts are not changed. This method does nothing if the specified group is already attached (i.e. it is silently ignored) and timeout_ms = -1. If the specified group is already attached and timeout_ms is different from -1, the client side timeout of each device composing the group given in parameter is set to timeout_ms milliseconds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group</td><td>The group to be attached </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmo_ms</td><td>The timeout value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8511861bcd0723b9e726e2bfaac6de3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8511861bcd0723b9e726e2bfaac6de3a">&#9670;&nbsp;</a></span>command_inout() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a> Tango::Group::command_inout </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on a group. </p>
<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on a group. This method is synchronous and does not return until replies are obtained or timeouts occurred. The parameter c is the name of the command. If fwd is set to true (the default), the request is also forwarded to subgroups. Otherwise, it is only applied to the local set of devices. <a class="el" href="classTango_1_1Command.html" title="This class is a class representing a command in the TANGO device server pattern.">Command</a> results are returned in a <a class="el" href="classTango_1_1GroupCmdReplyList.html" title="Group reply for a command execution.">GroupCmdReplyList</a>. See Obtaining command result for details (Chapter 4.7.3.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>). See also Case 1 of executing a command (Chapter 4.7.3.2 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The command name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group command result </dd></dl>

</div>
</div>
<a id="ab02f116ab2fcaed5850b0301dd8095a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02f116ab2fcaed5850b0301dd8095a7">&#9670;&nbsp;</a></span>command_inout() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a> Tango::Group::command_inout </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDeviceData.html">DeviceData</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with the same input data on a group. </p>
<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on each device in the group. This method is synchronous and does not return until replies are obtained or timeouts occurred. The parameter c is the name of the command. The second parameter d is a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> generic container for command carrying the command argument. See the Tango::DeviceData documentation. If fwd is set to true (the default), the request is also forwarded to subgroups. Otherwise, it is only applied to the local set of devices. <a class="el" href="classTango_1_1Command.html" title="This class is a class representing a command in the TANGO device server pattern.">Command</a> results are returned in a <a class="el" href="classTango_1_1GroupCmdReplyList.html" title="Group reply for a command execution.">GroupCmdReplyList</a>. See Obtaining command results (Chapter 4.7.3.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details. See also Case 2 of executing a command (Chapter 4.7.3.4 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The command name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The command data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group command result </dd></dl>

</div>
</div>
<a id="ae50c9d4d35e13d374dfc22afb6f6ab01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50c9d4d35e13d374dfc22afb6f6ab01">&#9670;&nbsp;</a></span>command_inout() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a> Tango::Group::command_inout </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDeviceData.html">DeviceData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with the different input data on a group (Using <a class="el" href="classDeviceData.html" title="Fundamental type for sending and receiving data from device commands.">DeviceData</a> class instances) </p>
<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on each device in the group. This method is synchronous and does not return until replies are obtained or timeouts occurred. This implementation of command_inout allows passing a specific input argument to each device in the group. In order to use this form of command_inout, the user must have an "a priori" and "perfect" knowledge of the devices order in the group. <br  />
 The parameter c is the name of the command. The std::vector d contains a specific argument value for each device in the group. Its size must equal Group::get_size(fwd). Otherwise, an exception is thrown. The order of the argument values must follows the order of the devices in the group (d[0] =&gt; 1st device, d[1] =&gt; 2nd device and so on). If fwd is set to true (the default), the request is also forwarded to subgroups. Otherwise, it is only applied to the local set of devices. <a class="el" href="classTango_1_1Command.html" title="This class is a class representing a command in the TANGO device server pattern.">Command</a> results are returned in a <a class="el" href="classTango_1_1GroupCmdReplyList.html" title="Group reply for a command execution.">GroupCmdReplyList</a>. See Obtaining command results (Chpater 4.7.3.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details. See also Case 3 of executing a command (Chapter 4.7.3.5 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example of this special form of command_inout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The command name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The command data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group command result </dd></dl>

</div>
</div>
<a id="ad54f51f9f9bbac8ad686199245274bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54f51f9f9bbac8ad686199245274bbf">&#9670;&nbsp;</a></span>command_inout() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a> Tango::Group::command_inout </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with the different input data on a group. </p>
<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on each device in the group. This method is synchronous and does not return until replies are obtained or timeouts occurred. This implementation of command_inout allows passing a specific input argument to each device in the group. In order to use this form of command_inout, the user must have an "a priori" and "perfect" knowledge of the devices order in the group. <br  />
 The parameter c is the name of the command. The std::vector d contains a specific argument value for each device in the group. Since this method is a template, d is able to contain any <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command argument type. Its size must equal Group::get_size(fwd). Otherwise, an exception is thrown. The order of the argument values must follows the order of the devices in the group (d[0] =&gt; 1st device, d[1] =&gt; 2nd device and so on). If fwd is set to true (the default), the request is also forwarded to subgroups. Otherwise, it is only applied to the local set of devices. <a class="el" href="classTango_1_1Command.html" title="This class is a class representing a command in the TANGO device server pattern.">Command</a> results are returned in a <a class="el" href="classTango_1_1GroupCmdReplyList.html" title="Group reply for a command execution.">GroupCmdReplyList</a>. See Obtaining command results (Chpater 4.7.3.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details. See also Case 3 of executing a command (Chapter 4.7.3.5 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example of this special form of command_inout.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The command input data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The command name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The command data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group command result </dd></dl>

</div>
</div>
<a id="a53d95994ae0c6e3836e33f8acef6a038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d95994ae0c6e3836e33f8acef6a038">&#9670;&nbsp;</a></span>command_inout_asynch() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::command_inout_asynch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fgt</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on each device in the group asynchronously. </p>
<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on each device in the group asynchronously. The method sends the request to all devices and returns immediately. Pass the returned request id to <a class="el" href="classTango_1_1Group.html#abed06d2a84d479a13c2e98781af748e8" title="Returns the results of an asynchronous command.">Group::command_inout_reply()</a> to obtain the results. The parameter c is the name of the command. The parameter fgt is a fire and forget flag. If set to true, it means that no reply is expected (i.e. the caller does not care about it and will not even try to get it). A false default value is provided. If the parameter fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. See Case 1 of Executing a command (Chapter 4.7.3.2 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The command name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fgt</td><td>The command data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call identifier </dd></dl>

</div>
</div>
<a id="a2bd15b110efd88ffa47233ba4244a273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd15b110efd88ffa47233ba4244a273">&#9670;&nbsp;</a></span>command_inout_asynch() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::command_inout_asynch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDeviceData.html">DeviceData</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fgt</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with same input data on each device in the group asynchronously. </p>
<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on each device in the group asynchronously. The method sends the request to all devices and returns immediately. Pass the returned request id to <a class="el" href="classTango_1_1Group.html#abed06d2a84d479a13c2e98781af748e8" title="Returns the results of an asynchronous command.">Group::command_inout_reply()</a> to obtain the results. The parameter c is the name of the command. The second parameter d is a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> generic container for command carrying the command argument. See the Tango::DeviceData documentation for details. The parameter fgt is a fire and forget flag. If set to true, it means that no reply is expected (i.e. the caller does not care about it and will not even try to get it). A false default value is provided. If the parameter fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. See Case 2 of Executing a command (Chapter 4.7.3.4 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The command name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The command input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fgt</td><td>The command data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call identifier </dd></dl>

</div>
</div>
<a id="a592a4fbe47296a6b27a142a38bbde6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a592a4fbe47296a6b27a142a38bbde6e8">&#9670;&nbsp;</a></span>command_inout_asynch() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::command_inout_asynch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDeviceData.html">DeviceData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fgt</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with different input data (using <a class="el" href="classDeviceData.html" title="Fundamental type for sending and receiving data from device commands.">DeviceData</a> object) on each device in the group asynchronously. </p>
<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on each device in the group asynchronously. The method send the request to all devices and return immediately. Pass the returned request id to <a class="el" href="classTango_1_1Group.html#abed06d2a84d479a13c2e98781af748e8" title="Returns the results of an asynchronous command.">Group::command_inout_reply</a> to obtain the results. This implementation of command_inout allows passing a specific input argument to each device in the group. In order to use this form of command_inout_asynch, the user must have an "a priori" and "perfect" knowledge of the devices order in the group. The parameter c is the name of the command. The std::vector d contains a specific argument value for each device in the group. Its size must equal Group::get_size(fwd). Otherwise, an exception is thrown. The order of the argument values must follows the order of the devices in the group (d[0] =&gt; 1st device, d[1] =&gt; 2nd device and so on). The parameter fgt is a fire and forget flag. If set to true, it means that no reply is expected (i.e. the caller does not care about it and will not even try to get it). A false default value is provided. If fwd is set to true (the default), the request is also forwarded to subgroups. Otherwise, it is only applied to the local set of devices. See Case 3 of Executing a command (Chapter 4.7.3.5 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example of this special form of command_inout.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The command name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The command input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fgt</td><td>The command data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call identifier </dd></dl>

</div>
</div>
<a id="a17b53cb8fb55e3b96d056cb9971aaab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17b53cb8fb55e3b96d056cb9971aaab4">&#9670;&nbsp;</a></span>command_inout_asynch() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::command_inout_asynch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fgt</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command with different input data on each device in the group asynchronously. </p>
<p>Executes a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command on each device in the group asynchronously. The method send the request to all devices and return immediately. Pass the returned request id to <a class="el" href="classTango_1_1Group.html#abed06d2a84d479a13c2e98781af748e8" title="Returns the results of an asynchronous command.">Group::command_inout_reply</a> to obtain the results. This implementation of command_inout allows passing a specific input argument to each device in the group. In order to use this form of command_inout_asynch, the user must have an "a priori" and "perfect" knowledge of the devices order in the group. The parameter c is the name of the command. The std::vector d contains a specific argument value for each device in the group. Since it's a template data type, d is able to contain any <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> command argument type. Its size must equal Group::get_size(fwd). Otherwise, an exception is thrown. The order of the argument values must follows the order of the devices in the group (d[0] =&gt; 1st device, d[1] =&gt; 2nd device and so on). The parameter fgt is a fire and forget flag. If set to true, it means that no reply is expected (i.e. the caller does not care about it and will not even try to get it). A false default value is provided. If fwd is set to true (the default), the request is also forwarded to subgroups. Otherwise, it is only applied to the local set of devices. See Case 3 of Executing a command (Chapter 4.7.3.5 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example of this special form of command_inout.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The command input data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The command name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The command input data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fgt</td><td>The command data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call identifier </dd></dl>

</div>
</div>
<a id="abed06d2a84d479a13c2e98781af748e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed06d2a84d479a13c2e98781af748e8">&#9670;&nbsp;</a></span>command_inout_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupCmdReplyList.html">GroupCmdReplyList</a> Tango::Group::command_inout_reply </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>req_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>tmo_ms</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results of an asynchronous command. </p>
<p>Returns the results of an asynchronous command. The first parameter req_id is a request identifier previously returned by one of the command_inout_asynch methods. For each device in the hierarchy, if the command result is not yet available, command_inout_replywait timeout_ms milliseconds before throwing an exception. This exception will be part of the global reply. If timeout_ms is set to 0, command_inout_reply waits "indefinitely". <a class="el" href="classTango_1_1Command.html" title="This class is a class representing a command in the TANGO device server pattern.">Command</a> results are returned in a <a class="el" href="classTango_1_1GroupCmdReplyList.html" title="Group reply for a command execution.">GroupCmdReplyList</a>. See Obtaining command results (Chapter 4.7.3.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req_id</td><td>The request identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmo_ms</td><td>The timeout value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group command result </dd></dl>

</div>
</div>
<a id="a2885b00242d3a2d199836e48186dd71e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2885b00242d3a2d199836e48186dd71e">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Tango::Group::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the hierarchy contains groups and/or devices which name matches the specified pattern. </p>
<p>Returns true if the hierarchy contains groups and/or devices which name matches the specified pattern. Returns false otherwise. The pattern can be a fully qualified or simple group name, a device name or a device name pattern. If fwd is set to true (the default), the request is also forwarded to subgroups. Otherwise, it is only applied to the local set of elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The device selection pattern </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the hierarchy contains the element </dd></dl>

</div>
</div>
<a id="adc7d5db7e814e378bf30f940865885b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc7d5db7e814e378bf30f940865885b8">&#9670;&nbsp;</a></span>get_device() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDeviceProxy.html">DeviceProxy</a>* Tango::Group::get_device </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the specified device. </p>
<p>Returns a reference to the specified device or NULL if there is no device by that name in the group. This method may throw an exception in case the specified device belongs to the group but can’t be reached (not registered, down...). See example below. See also the Tango::DeviceProxy class documentation for details. </p><div class="fragment"><div class="line"><span class="keywordflow">try</span></div>
<div class="line">{</div>
<div class="line">   Tango::DeviceProxy *dp = g-&gt;get_device(<span class="stringliteral">&quot;my/device/01&quot;</span>);</div>
<div class="line">   <span class="keywordflow">if</span> (dp == 0)</div>
<div class="line">   {</div>
<div class="line">      <span class="comment">// my/device/01 does not belongs to the group</span></div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span> (<span class="keyword">const</span> Tango::DevFailed &amp;df)</div>
<div class="line">{</div>
<div class="line">   <span class="comment">// my/device/01 belongs to the group but can’t be reached</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> The request is systematically forwarded to subgroups (i.e. if no device named device_name could be found in the local set of devices, the request is forwarded to subgroups). Be aware that a group always gets the ownership of its children and deletes them when it is itself deleted. Therefore, never try to delete a <a class="el" href="classDeviceProxy.html" title="High level class which provides the client with an easy-to-use interface to TANGO devices.">DeviceProxy</a> returned by the <a class="el" href="classTango_1_1Group.html#adc7d5db7e814e378bf30f940865885b8" title="Returns a reference to the specified device.">Group::get_device()</a>method. Use the <a class="el" href="classTango_1_1Group.html#acd7763925b6e27ccf237b13fa7f98009" title="Removes any group or device which name matches the specified pattern.">Tango::Group::remove()</a> method instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">device_name</td><td>The device name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the hierarchy contains the element </dd></dl>

</div>
</div>
<a id="a29685f1ad173310c2cf695390cedd362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29685f1ad173310c2cf695390cedd362">&#9670;&nbsp;</a></span>get_device() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDeviceProxy.html">DeviceProxy</a>* Tango::Group::get_device </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the "idx-th" device in the hierarchy. </p>
<p>Returns a reference to the "idx-th" device in the hierarchy or NULL if the hierarchy contains less than "idx" devices. This method may throw an exception in case the specified device belongs to the group but can’t be reached (not registered, down...). See previous example. See also the Tango::DeviceProxy class documentation for details. The request is systematically forwarded to subgroups (i.e. if the local set of devices contains less than "idx" devices, the request is forwarded to subgroups). Be aware that a group always gets the ownership of its children and deletes them when it is itself deleted. Therefore, never try to delete a <a class="el" href="classDeviceProxy.html" title="High level class which provides the client with an easy-to-use interface to TANGO devices.">DeviceProxy</a> returned by the <a class="el" href="classTango_1_1Group.html#adc7d5db7e814e378bf30f940865885b8" title="Returns a reference to the specified device.">Group::get_device()</a>method. Use the <a class="el" href="classTango_1_1Group.html#acd7763925b6e27ccf237b13fa7f98009" title="Removes any group or device which name matches the specified pattern.">Tango::Group::remove()</a> method instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The device name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>device reference </dd></dl>

</div>
</div>
<a id="a35a3426e304c3d87607997261aff1d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35a3426e304c3d87607997261aff1d22">&#9670;&nbsp;</a></span>get_device_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; Tango::Group::get_device_list </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the list of devices currently in the hierarchy. </p>
<p>Returns the list of devices currently in the hierarchy. If fwd is set to true (the default) the request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. Considering the following hierarchy: </p><div class="fragment"><div class="line">g2-&gt;add(<span class="stringliteral">&quot;my/device/04&quot;</span>); g2-&gt;add(<span class="stringliteral">&quot;my/device/05&quot;</span>);</div>
<div class="line"> </div>
<div class="line">g4-&gt;add(<span class="stringliteral">&quot;my/device/08&quot;</span>); g4-&gt;add(<span class="stringliteral">&quot;my/device/09&quot;</span>);</div>
<div class="line"> </div>
<div class="line">g3-&gt;add(<span class="stringliteral">&quot;my/device/06&quot;</span>);</div>
<div class="line">g3-&gt;addg(g4);</div>
<div class="line">g3-&gt;add(<span class="stringliteral">&quot;my/device/07&quot;</span>);</div>
<div class="line"> </div>
<div class="line">g1-&gt;add(<span class="stringliteral">&quot;my/device/01&quot;</span>);</div>
<div class="line">g1-&gt;add(g2);</div>
<div class="line">g1-&gt;add(<span class="stringliteral">&quot;my/device/03&quot;</span>);</div>
<div class="line">g1-&gt;add(g3);</div>
<div class="line">g1-&gt;add(<span class="stringliteral">&quot;my/device/02&quot;</span>);</div>
</div><!-- fragment --><p> The returned vector content depends on the value of the forward option. If set to true, the results will be organized as follows: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; dl = g1-&gt;get_device_list(<span class="keyword">true</span>);</div>
</div><!-- fragment --><p> dl[0] contains "my/device/01" which belongs to g1 <br  />
 dl[1] contains "my/device/04" which belongs to g1.g2 <br  />
 dl[2] contains "my/device/05" which belongs to g1.g2 <br  />
 dl[3] contains "my/device/03" which belongs to g1 <br  />
 dl[4] contains "my/device/06" which belongs to g1.g3 <br  />
 dl[5] contains "my/device/08" which belongs to g1.g3.g4 <br  />
 dl[6] contains "my/device/09" which belongs to g1.g3.g4 <br  />
 dl[7] contains "my/device/07" which belongs to g1.g3 <br  />
 dl[8] contains "my/device/02" which belongs to g1 <br  />
 <br  />
 If the forward option is set to false, the results are: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; dl = g1-&gt;get_device_list(<span class="keyword">false</span>);</div>
</div><!-- fragment --><p> dl[0] contains "my/device/01" which belongs to g1 <br  />
 dl[1] contains "my/device/03" which belongs to g1 <br  />
 dl[2] contains "my/device/02" which belongs to g1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>group size </dd></dl>

</div>
</div>
<a id="a75ddf85f5805e6e99656cbe554ecf96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75ddf85f5805e6e99656cbe554ecf96e">&#9670;&nbsp;</a></span>get_group()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTango_1_1Group.html">Group</a>* Tango::Group::get_group </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the specified group. </p>
<p>Returns a reference to the specified group or NULL if there is no group by that name. The group_name can be a fully qualified name. Considering the following group: </p><pre class="fragment">-&gt; gauges
   | -&gt; cell-01
   |     | -&gt; penning
   |     |     | -&gt; ...
   |     | -&gt; pirani
   |     |     | -&gt; ...
   | -&gt; cell-02
   |     | -&gt; penning
   |     |     | -&gt; ...
   |     | -&gt; pirani
   |     |     | -&gt; ...
   | -&gt; cell-03
   |     | -&gt; ...</pre><p> A call to gauges-&gt;get_group("penning") returns the first group named "penning" in the hierarchy (i.e. gauges.cell-01.penning)while gauges-&gt;get_group("gauges.cell-02.penning”) returns the specified group. The request is systematically forwarded to subgroups (i.e. if no group named group_name could be found in the local set of elements, the request is forwarded to subgroups). Be aware that a group always gets the ownership of its children and deletes them when it is itself deleted. Therefore, never try to delete a <a class="el" href="classTango_1_1Group.html" title="High level class allowing the user to handle Tango group.">Group</a> returned by the <a class="el" href="classTango_1_1Group.html#a75ddf85f5805e6e99656cbe554ecf96e" title="Returns a reference to the specified group.">Group::get_group()</a> method. Use the <a class="el" href="classTango_1_1Group.html#acd7763925b6e27ccf237b13fa7f98009" title="Removes any group or device which name matches the specified pattern.">Tango::Group::remove()</a> method instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">group_name</td><td>The group name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>group pointer </dd></dl>

</div>
</div>
<a id="a1afb6e934e20fb757538b873fef265e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afb6e934e20fb757538b873fef265e5">&#9670;&nbsp;</a></span>get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::get_size </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of devices in the hierarchy. </p>
<p>Return the number of devices in the hierarchy (respectively the number of device in the group) if the forward option is set to true (respectively set to false)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>group size </dd></dl>

</div>
</div>
<a id="aea3b781cd10d28770cb584c55c065534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3b781cd10d28770cb584c55c065534">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDeviceProxy.html">DeviceProxy</a>* Tango::Group::operator[] </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the "idx-th" device in the hierarchy. </p>
<p>Returns a reference to the "idx-th" device in the hierarchy or NULL if the hierarchy contains less than "idx" devices. See the Tango::DeviceProxy class documentation for details. The request is systematically forwarded to subgroups (i.e. if the local set of devices contains less than "idx" devices, the request is forwarded to subgroups). Be aware that a group always gets the ownership of its children and deletes them when it is itself deleted. Therefore, never try to delete a <a class="el" href="classDeviceProxy.html" title="High level class which provides the client with an easy-to-use interface to TANGO devices.">DeviceProxy</a> returned by the <a class="el" href="classTango_1_1Group.html#adc7d5db7e814e378bf30f940865885b8" title="Returns a reference to the specified device.">Group::get_device()</a>method. Use the <a class="el" href="classTango_1_1Group.html#acd7763925b6e27ccf237b13fa7f98009" title="Removes any group or device which name matches the specified pattern.">Tango::Group::remove()</a> method instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">idx</td><td>The device name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>device reference </dd></dl>

</div>
</div>
<a id="aa7cd5c6f1be1a85c244c7a4ec99081ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7cd5c6f1be1a85c244c7a4ec99081ec">&#9670;&nbsp;</a></span>ping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Tango::Group::ping </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ping all devices in a group. </p>
<p>Ping all devices in a group. This method returns true if all devices in the group are alive, false otherwise. If fwd is set to true (the default), the request is also forwarded to subgroups. Otherwise, it is only applied to the local set of devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all devices are alive </dd></dl>

</div>
</div>
<a id="a3c584b30ee4e69eed2de59cb548c4134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c584b30ee4e69eed2de59cb548c4134">&#9670;&nbsp;</a></span>read_attribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupAttrReplyList.html">GroupAttrReplyList</a> Tango::Group::read_attribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an attribute on each device in the group. </p>
<p>Reads an attribute on each device in the group. This method is synchronous and does not return until replies are obtained or timeouts occurred. The parameter a is the name of the attribute to read. If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. <a class="el" href="classTango_1_1Attribute.html" title="This class represents a Tango attribute.">Attribute</a> values are returned in a <a class="el" href="classTango_1_1GroupAttrReplyList.html" title="Group reply for a read_attribute execution.">GroupAttrReplyList</a>. See Obtaining attribute values (Chapter 4.7.4.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details. See also Reading an attribute (Chapter 4.7.4 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The attribute name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group attribute data </dd></dl>

</div>
</div>
<a id="a08fa50b55ebad69d6fd819f658703997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fa50b55ebad69d6fd819f658703997">&#9670;&nbsp;</a></span>read_attribute_asynch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::read_attribute_asynch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an attribute on each device in the group asynchronously. </p>
<p>Reads an attribute on each device in the group asynchronously. The method sends the request to all devices and returns immediately. Pass the returned request id to <a class="el" href="classTango_1_1Group.html#a9c580ba756e84843f29e126efb8c1986" title="Returns the results of an asynchronous attribute reading.">Group::read_attribute_reply()</a> to obtain the results. The parameter a is the name of the attribute to read. If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. The last parameter (rsv) is reserved for internal purpose and should not be modify. It may disappear in a near future. See Reading an attribute (Chapter 4.7.4 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The attribute name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call identifier </dd></dl>

</div>
</div>
<a id="a9c580ba756e84843f29e126efb8c1986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c580ba756e84843f29e126efb8c1986">&#9670;&nbsp;</a></span>read_attribute_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupAttrReplyList.html">GroupAttrReplyList</a> Tango::Group::read_attribute_reply </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>req_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>tmo_ms</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results of an asynchronous attribute reading. </p>
<p>Returns the results of an asynchronous attribute reading. The first parameter req_id is a request identifier previously returned by read_attribute_asynch. For each device in the hierarchy, if the attribute value is not yet available, read_attribute_reply wait timeout_ms milliseconds before throwing an exception. This exception will be part of the global reply. If timeout_ms is set to 0, read_attribute_reply waits "indefinitely". Replies are returned in a <a class="el" href="classTango_1_1GroupAttrReplyList.html" title="Group reply for a read_attribute execution.">GroupAttrReplyList</a>. See Obtaining attribute values (Chapter 4.7.4.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req_id</td><td>The attribute name list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmo_ms</td><td>The timeout value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group attribute data </dd></dl>

</div>
</div>
<a id="ab4088df9970f1f1c7d6ae8c29563369f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4088df9970f1f1c7d6ae8c29563369f">&#9670;&nbsp;</a></span>read_attributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupAttrReplyList.html">GroupAttrReplyList</a> Tango::Group::read_attributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>al</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads several attributes on each device in the group. </p>
<p>Reads several attributes on each device in the group. This method is synchronous and does not return until replies are obtained or timeouts occurred. The parameter al is the list of attributes to be read. If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. <a class="el" href="classTango_1_1Attribute.html" title="This class represents a Tango attribute.">Attribute</a> values are returned in a <a class="el" href="classTango_1_1GroupAttrReplyList.html" title="Group reply for a read_attribute execution.">GroupAttrReplyList</a>. See Obtaining attribute values (Chapter 4.7.4.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details. See also Reading an attribute (Chapter 4.7.4 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">al</td><td>The attribute name list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group attribute data </dd></dl>

</div>
</div>
<a id="a9431b4c0673e3824c31b00028e894d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9431b4c0673e3824c31b00028e894d31">&#9670;&nbsp;</a></span>read_attributes_asynch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::read_attributes_asynch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>al</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads several attributes on each device in the group asynchronously. </p>
<p>Reads several attribute on each device in the group asynchronously. The method sends the request to all devices and returns immediately. Pass the returned request id to <a class="el" href="classTango_1_1Group.html#a9c580ba756e84843f29e126efb8c1986" title="Returns the results of an asynchronous attribute reading.">Group::read_attribute_reply()</a> to obtain the results. The parameter a is the name of the attribute to read. If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. The last parameter (rsv) is reserved for internal purpose and should not be modify. It may disappear in a near future. See Reading an attribute (Chapter 4.7.4 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">al</td><td>The attribute name list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call identifier </dd></dl>

</div>
</div>
<a id="ab1a83261058e5c52803e502c01380b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a83261058e5c52803e502c01380b79">&#9670;&nbsp;</a></span>read_attributes_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupAttrReplyList.html">GroupAttrReplyList</a> Tango::Group::read_attributes_reply </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>req_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>tmo_ms</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the results of an asynchronous attributes reading. </p>
<p>Returns the results of an asynchronous attributes reading. The first parameter req_id is a request identifier previously returned by read_attribute_asynch. For each device in the hierarchy, if the attribute value is not yet available, read_attribute_reply wait timeout_ms milliseconds before throwing an exception. This exception will be part of the global reply. If timeout_ms is set to 0, read_attribute_reply waits "indefinitely". Replies are returned in a <a class="el" href="classTango_1_1GroupAttrReplyList.html" title="Group reply for a read_attribute execution.">GroupAttrReplyList</a>. See Obtaining attribute values (Chapter 4.7.4.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req_id</td><td>The attribute name list </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmo_ms</td><td>The timeout value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group attribute data </dd></dl>

</div>
</div>
<a id="acd7763925b6e27ccf237b13fa7f98009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7763925b6e27ccf237b13fa7f98009">&#9670;&nbsp;</a></span>remove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Tango::Group::remove </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes any group or device which name matches the specified pattern. </p>
<p>The pattern parameter can be a group name, a device name or a device name pattern (e.g domain_* /family/member_*). Since we can have groups with the same name in the hierarchy, a group name can be fully qualified to specify which group should be removed. Considering the following group: </p><pre class="fragment"> -&gt; gauges
    | -&gt; cell-01
    |     | -&gt; penning
    |     |     | -&gt; ...
    |     | -&gt; pirani
    |     |     | -&gt; ...
    | -&gt; cell-02
    |     | -&gt; penning
    |     |     | -&gt; ...
    |     | -&gt; pirani
    |     |     | -&gt; ...
    | -&gt; cell-03
    |     | -&gt; ...</pre><p> A call to gauges-&gt;remove("penning") will remove any group named "penning" in the hierarchy while gauges-&gt;remove("gauges.cell-02.penning") will only remove the specified group. If fwd is set to true (the default), the remove request is also forwarded to subgroups. Otherwise, it is only applied to the local set of elements. For instance, the following code remove any stepper motor in the hierarchy: </p><div class="fragment"><div class="line">  root_group-&gt;remove(<span class="stringliteral">&quot;*/stepper_motor/*&quot;</span>);</div>
<div class="line">* </div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pattern</td><td>The device selection pattern </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2561673c34638016106a6fba3c0b95ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2561673c34638016106a6fba3c0b95ee">&#9670;&nbsp;</a></span>remove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Tango::Group::remove </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes any group or device which name matches any of the specified patterns. </p>
<p>The patterns parameter can be an array of group names and/or device names and/or device name patterns. Since we can have groups with the same name in the hierarchy, a group name can be fully qualified to specify which group should be removed. See previous method for details. If fwd is set to true (the default), the remove request is also forwarded to subgroups. Otherwise, it is only applied to the local set of elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">patterns</td><td>The device selection patterns </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12404b76c3e64df47467a1260591e7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12404b76c3e64df47467a1260591e7df">&#9670;&nbsp;</a></span>remove_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Tango::Group::remove_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all elements in the group. </p>
<p>Removes all elements in the group. After such a call, the group is empty. </p>

</div>
</div>
<a id="a92242b89511557c3296480ee19b790b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92242b89511557c3296480ee19b790b2">&#9670;&nbsp;</a></span>set_timeout_millis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void Tango::Group::set_timeout_millis </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tmo_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set client side timeout for all devices in the group. </p>
<p>Set client side timeout for all devices composing the group in milliseconds. Any method which takes longer than this time to execute will throw an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tmo_ms</td><td>The timeout value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64da6f972d7dca15b192c66226e3d4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64da6f972d7dca15b192c66226e3d4c7">&#9670;&nbsp;</a></span>write_attribute() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupReplyList.html">GroupReplyList</a> Tango::Group::write_attribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDeviceAttribute.html">DeviceAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an attribute on each device in the group. </p>
<p>Writes an attribute on each device in the group. This method is synchronous and does not return until acknowledgements are obtained or timeouts occurred. The first parameter d is a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> generic container for attribute carrying both the attribute name and the value. See the Tango::DeviceAttribute documentation for details. If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. Acknowledgements are returned in a <a class="el" href="classTango_1_1GroupReplyList.html" title="Group reply for a write_attribute execution.">GroupReplyList</a>. See Obtaining acknowledgements (Chapter 4.7.5.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details. See also Case 1 of Writing an attribute (Chapter 4.7.5.2 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The attribute name and value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group reply </dd></dl>

</div>
</div>
<a id="a5b513a1564a1a4f9e5482dfcef528d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b513a1564a1a4f9e5482dfcef528d0c">&#9670;&nbsp;</a></span>write_attribute() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupReplyList.html">GroupReplyList</a> Tango::Group::write_attribute </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes one attributes on each device in the group with specific value per device. </p>
<p>Writes an attribute on each device in the group. This method is synchronous and does not return until replies are obtained or timeouts occurred. This implementation of write_attribute allows writing a specific value to each device in the group. In order to use this form of write_attribute, the user must have an "a priori" and "perfect" knowledge of the devices order in the group. The parameter a is the name of the attribute. The std::vector d contains a specific value for each device in the group. Since this method is a template, d is able to contain any <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> attribute type. Its size must equal Group::get_size(fwd). Otherwise, an exception is thrown. The order of the attribute values must follows the order of the devices in the group (d[0] =&gt; 1st device, d[1] =&gt; 2nd device and so on). If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. Acknowledgements are returned in a <a class="el" href="classTango_1_1GroupReplyList.html" title="Group reply for a write_attribute execution.">GroupReplyList</a>. See Obtaining acknowledgements (Chapter 4.7.5.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details. See also Case 2 of Writing an attribute (Chapter 4.7.5.3 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The attribute data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The attribute name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The attribute names and values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group reply </dd></dl>

<p class="reference">References <a class="el" href="classTango_1_1Group.html#aa300f78715baea10d390b7e7489e0506">write_attribute_reply()</a>.</p>

</div>
</div>
<a id="ac05e427721de6903871b6c2dc505dec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05e427721de6903871b6c2dc505dec7">&#9670;&nbsp;</a></span>write_attribute() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupReplyList.html">GroupReplyList</a> Tango::Group::write_attribute </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDeviceAttribute.html">DeviceAttribute</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes several attributes on each device in the group (using <a class="el" href="classDeviceAttribute.html" title="Fundamental type for sending an dreceiving data to and from device attributes.">DeviceAttribute</a>) </p>
<p>Writes several attributes on each device in the group. This method is synchronous and does not return until acknowledgements are obtained or timeouts occurred. The first parameter d is a vector of <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> generic container for attribute carrying both the attribute name and the value. See the Tango::DeviceAttribute documentation for details. If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. Acknowledgements are returned in a <a class="el" href="classTango_1_1GroupReplyList.html" title="Group reply for a write_attribute execution.">GroupReplyList</a>. See Obtaining acknowledgements (Chapter 4.7.5.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details. See also Case 2 of Writing an attribute (Chapter 4.7.5.3 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The attribute names and values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The group reply </dd></dl>

</div>
</div>
<a id="a2ead1c134a086855da1e809aa8f13d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ead1c134a086855da1e809aa8f13d03">&#9670;&nbsp;</a></span>write_attribute_asynch() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::write_attribute_asynch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDeviceAttribute.html">DeviceAttribute</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an attribute on each device in the group asynchronously. </p>
<p>Write an attribute on each device in the group asynchronously. The method sends the request to all devices and returns immediately. Pass the returned request id to <a class="el" href="classTango_1_1Group.html#aa300f78715baea10d390b7e7489e0506" title="Returns the acknowledgements of an asynchronous attribute writing.">Group::write_attribute_reply()</a> to obtain the acknowledgements. The first parameter d is a <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> generic container for attribute carrying both the attribute name and the value. See the Tango::DeviceAttribute documentation for details. If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. See Case 1 of Writing an attribute (Chapter 4.7.5.2 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The attribute name and value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call identifier </dd></dl>

</div>
</div>
<a id="a187f0b29e02bf82b74f21b55c4252d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187f0b29e02bf82b74f21b55c4252d62">&#9670;&nbsp;</a></span>write_attribute_asynch() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::write_attribute_asynch </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an attribute on each device in the group asynchronously (Without <a class="el" href="classDeviceAttribute.html" title="Fundamental type for sending an dreceiving data to and from device attributes.">DeviceAttribute</a> data) </p>
<p>Writes an attribute on each device in the group asynchronously. The method sends the request to all devices and returns immediately. Pass the returned request id to <a class="el" href="classTango_1_1Group.html#aa300f78715baea10d390b7e7489e0506" title="Returns the acknowledgements of an asynchronous attribute writing.">Group::write_attribute_reply()</a> to obtain the acknowledgements. This implementation of write_attribute_asynch allows writing a specific value to each device in the group. In order to use this form of write_attribute_asynch, the user must have an "a priori" and "perfect" knowledge of the devices order in the group. The parameter a is the name of the attribute. The std::vector d contains a specific value for each device in the group. Since this method is a template, d is able to contain any <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> attribute type. Its size must equal Group::get_size(fwd). Otherwise, an exception is thrown. The order of the attribute values must follows the order of the devices in the group (d[0] =&gt; 1st device, d[1] =&gt; 2nd device and so on). If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. See Case2 of Writing an attribute (Chapter 4.7.5.3 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The attribute data type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The attribute name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The attribute value(s) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call identifier </dd></dl>

</div>
</div>
<a id="a2edbe29d80b0c686840c01bac7304197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edbe29d80b0c686840c01bac7304197">&#9670;&nbsp;</a></span>write_attribute_asynch() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Tango::Group::write_attribute_asynch </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classDeviceAttribute.html">DeviceAttribute</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes several attributes on each device in the group asynchronously. </p>
<p>Write several attributes on each device in the group asynchronously. The method sends the request to all devices and returns immediately. Pass the returned request id to <a class="el" href="classTango_1_1Group.html#aa300f78715baea10d390b7e7489e0506" title="Returns the acknowledgements of an asynchronous attribute writing.">Group::write_attribute_reply()</a> to obtain the acknowledgements. The first parameter d is a vector of <a class="el" href="namespaceTango.html" title="=============================================================================">Tango</a> generic container for attribute carrying both the attribute name and the value. See the Tango::DeviceAttribute documentation for details. If fwd is set to true (the default) request is forwarded to subgroups. Otherwise, it is only applied to the local set of devices. See Case 1 of Writing an attribute (Chapter 4.7.5.2 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for an example.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d</td><td>The attribute name and value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fwd</td><td>The forward flag </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The call identifier </dd></dl>

</div>
</div>
<a id="aa300f78715baea10d390b7e7489e0506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa300f78715baea10d390b7e7489e0506">&#9670;&nbsp;</a></span>write_attribute_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTango_1_1GroupReplyList.html">GroupReplyList</a> Tango::Group::write_attribute_reply </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>req_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>tmo_ms</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the acknowledgements of an asynchronous attribute writing. </p>
<p>Returns the acknowledgements of an asynchronous attribute writing. The first parameter req_id is a request identifier previously returned by one of the write_attribute_asynch implementation. For each device in the hierarchy, if the acknowledgement is not yet available, write_attribute_replywait timeout_ms milliseconds before throwing an exception. This exception will be part of the global reply. If timeout_ms is set to 0, write_attribute_reply waits "indefinitely". Acknowledgements are returned in a <a class="el" href="classTango_1_1GroupReplyList.html" title="Group reply for a write_attribute execution.">GroupReplyList</a>. See Obtaining acknowledgements (Chapter 4.7.5.1 in <a href="http://www.esrf.eu/computing/cs/tango/tango_doc/kernel_doc/ds_prog/index.html" target="new">Tango book</a>) for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req_id</td><td>The request identifier </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tmo_ms</td><td>The timeout value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute writing acknowledgements </dd></dl>

<p class="reference">Referenced by <a class="el" href="classTango_1_1Group.html#a5b513a1564a1a4f9e5482dfcef528d0c">write_attribute()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>group.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceTango.html">Tango</a></li><li class="navelem"><a class="el" href="classTango_1_1Group.html">Group</a></li>
    <li class="footer">Generated on Thu Oct 8 2020 13:28:13 for Tango Core Classes Reference by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.19 </li>
  </ul>
</div>
</body>
</html>
